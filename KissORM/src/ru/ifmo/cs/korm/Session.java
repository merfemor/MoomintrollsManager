package ru.ifmo.cs.korm;

import ru.ifmo.cs.korm.mapping.MappingAttribute;
import ru.ifmo.cs.korm.mapping.MappingTable;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Session {
    private SQLSyntax sqlSyntax;
    private Connection connection;
    private Map<Class, MappingTable> mapping = new HashMap<>();

    public Session(Connection connection, SQLSyntax sqlSyntax) {
        this.connection = connection;
        this.sqlSyntax = sqlSyntax;
    }

    public void close() throws SQLException {
        connection.close();
    }

    public Session addClass(Class annotatedClass) throws SQLException {
        MappingTable mappingTable = new MappingTable(annotatedClass);
        assertTableExists(mappingTable);
        this.mapping.put(annotatedClass, mappingTable);
        return this;
    }

    private void assertTableExists(MappingTable table) throws SQLException {
        DatabaseMetaData metaData = connection.getMetaData();
        ResultSet tables = metaData.getTables(
                null, null, table.getName(), null);
        if (!tables.next()) {
            // TODO: create table
            throw new RuntimeException("Table " + table.getName() + " isn't exists");
        }
    }

    public void add(Object[] o) {
        if (o.length == 0)
            return;
        MappingTable mappingTable = mapping.get(o[0].getClass());
        if (mappingTable == null) {
            throw new IllegalArgumentException("Table for class " + o.getClass() + " isn't mapped");
        }
        String sql = "INSERT INTO " + mappingTable.getName() + " (" + mappingTable.getNotAutoGeneratedAttributes()
                .stream()
                .map(ma -> ma.tName)
                .collect(Collectors.joining(", ")) +
                ") VALUES (" +
                new String(new char[mappingTable.getNotAutoGeneratedAttributes().size()])
                        .replace("\0", "?").replace("??", "?, ?").replace("??", "?, ?") +
                ");";

        PreparedStatement statement;
        try {
            connection.setAutoCommit(false);
            statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            for (Object object : o) {
                int j = 1;
                for (MappingAttribute ma : mappingTable.getNotAutoGeneratedAttributes()) {
                    try {
                        statement.setObject(j,
                                sqlSyntax.toJdbcObject(ma.getter.invoke(object))
                        );
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new IllegalArgumentException(e);
                    }
                    j++;
                }

                statement.executeUpdate();
                if (!mappingTable.getAutoGeneratedAttributes().isEmpty()) {
                    ResultSet autoGenIds = statement.getGeneratedKeys();
                    for (MappingAttribute ma : mappingTable.getAutoGeneratedAttributes()) {
                        autoGenIds.next();
                        ma.setter.invoke(
                                object,
                                sqlSyntax.fromJdbcObject(
                                        autoGenIds.getObject(
                                                ma.tName,
                                                sqlSyntax.toSQLtype(ma.oClass)
                                        ), ma.oClass
                                )
                        );
                    }
                }
            }
            connection.commit();
            connection.setAutoCommit(true);
        } catch (SQLException | IllegalAccessException | InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    public <T> T[] getData(Class<T> c) {
        MappingTable table = mapping.get(c);
        List<T> collection = new ArrayList<>();
        if (table == null)
            throw new IllegalArgumentException("No mapping for class " + c);
        try {
            ResultSet resultSet = connection.createStatement().executeQuery("SELECT * FROM " + table.name);
            while (resultSet.next()) {
                T o = c.newInstance();
                Stream.concat(
                        table.getAutoGeneratedAttributes().stream(),
                        table.getNotAutoGeneratedAttributes().stream())
                        .forEach(ma -> {

                        });
                for (MappingAttribute ma : table.getAutoGeneratedAttributes())
                    ma.setter.invoke(
                            o,
                            sqlSyntax.fromJdbcObject(
                                    resultSet.getObject(ma.tName, sqlSyntax.toSQLtype(ma.oClass)),
                                    ma.oClass));
                for (MappingAttribute ma : table.getNotAutoGeneratedAttributes())
                    ma.setter.invoke(
                            o,
                            sqlSyntax.fromJdbcObject(
                                    resultSet.getObject(ma.tName, sqlSyntax.toSQLtype(ma.oClass)),
                                    ma.oClass));
                collection.add(o);
            }
        } catch (SQLException | IllegalAccessException | InstantiationException e) {
            throw new IllegalArgumentException(e);
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        T[] ts = (T[]) Array.newInstance(c, 0);
        return collection.toArray(ts);
    }

    // TODO: update(), remove() methods
}
